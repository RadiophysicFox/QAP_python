### Функции ###

# объявили функцию для подсчета количества символов в неком абстрактном тексте
def char_frequency(text):
   text = text.lower()
   text = text.replace(" ", "")
   text = text.replace("\n", "")

   count = {}  # для подсчета символов и их количества
   for char in text:
       if char in count:  # если символ уже встречался, то увеличиваем его количество на 1
           count[char] += 1
       else:
           count[char] = 1

   for char, cnt in count.items():
       print(f"Символ {char} встречается {cnt} раз")

# Функция print_2_add_2, которая будет складывать 2 и 2, а затем печатать этот результат:

def print_2_add_2():
    print(2 + 2)


print_2_add_2()

# Функция, которая будет возводить любое число в степень 2.
def pow_func(base):
   print(base ** 2)

pow_func(3)  # 9
pow_func(5)  # 25

# Пусть наша функция теперь возводит число в любую степень, но по умолчанию возводит в степень 2
def pow_func(base, n=2):
   print(base ** n)

pow_func(3)  # 9
pow_func(5, 3)  # 125

# Функция, которая проверяет, является ли число n делителем числа a и выводит на экран соответствующее сообщение:
def check_num(a, n):
    if a % n == 0:
        print(f"Число {n} является делителем числа {a}")
    else:
        print(f"Число {n} не является делителем числа {a}")

# Функция, которая печатает «обратную лесенку»:
def stairs_desc(n):
    for i in range(n, 0, -1):
        print('*' * i)

# Функция, которая будет возвращать количество делителей числа а:
def get_multipliers(a):
   count = 0
   for n in range(1, a + 1):
       if a % n == 0:
           count += 1

   return count

# Функция, которая проверяет, является ли данная строка палиндромом или нет:
def check_palindrome(str_):
   str_ = str_.lower()
   str_ = str_.replace(" ", "")

   if str_ == str_[::-1]:
       return True
   else:
       return False

### Области видимости ###

# Локальная область видимости
# Переменные, определяемые внутри инструкции def, видны только программному коду внутри инструкции def:
def local():
   x = 5  # локальная переменная
   print(x)

x = 10
local()
print(x)

# 5
# 10

# Глобальная область видимости
def local():
  print(x)  # так как x нет в локальной области видимости, мы берем её из глобальной области

x = 10
local()
print(x)

# 10
# 10

# Оператор global, который объявляет переменную доступной для блока кода, следующим за оператором:
x = 3


def func():
   global x # объявляем, что переменная является глобальной
   print(x)
   x = 5
   x += 5
   return x


func()
print(x)

# Нелокальная область видимости
# Nonlocal используется чаще всего во вложенных функциях, когда мы хотим дать интерпретатору понять, что для
# вложенной функции определенная переменная не является локальной, но она и не является глобальной в общем смысле:
def get_mul_func(m):
    nonlocal_m = m

    def local_mul(n):
        return n * nonlocal_m

    return local_mul


two_mul = get_mul_func(2)  # возвращаем функцию, которая будет умножать числа на 2
two_mul(5)  # 5 * 2

### Запакованные переменные, или что такое *args и **kwargs ###
# Важная особенность: все именованные аргументы должны идти строго после позиционных, как при объявлении функций,
# так и при их вызове.

# Правильно
func(a, b, c=3)

# Неправильно
func(a=1, b, c)

# Оператор распаковки позволяет работать со значением последовательности, а не с самой последовательностью.
# В первом случае функция print печатает список, а во втором — все значения списка:
print(a) # [1, 2, 3]
print(*a)  # 1 2 3

# Чтобы функция могла принимать неограниченное количество позиционных аргументов, есть специальная конструкция
# *args, а для именованных аргументов — **kwargs.
# args — это кортеж, а kwargs — это словарь.
def adder(*nums):
    sum_ = 0
    for n in nums:
        sum_ += n

    return sum_


print(adder())  # 0
print(adder(1))  # 1
print(adder(1, 2))  # 3
print(adder(1, 2, 3))  # 6


# Изменяемые типы данных как аргументы по умолчанию
# установим аргумент name_arg пустым а внутри функции будем проверять его
def correct_func(name_arg=None):
   if name_arg is None:
       name_arg = []
   print("Аргумент до изменения", name_arg)
   name_arg.append(1)
   print("Аргумент после изменения", name_arg)

# вызовем два раза одну и ту же функцию
correct_func()
print('-----')
correct_func()
print('-----')
correct_func([123])
print('-----')
correct_func(name_arg=[123])

# Аргумент до изменения []
# Аргумент после изменения [1]
# -----
# Аргумент до изменения []
# Аргумент после изменения [1]
# -----
# Аргумент до изменения [123]
# Аргумент после изменения [123, 1]
# -----
# Аргумент до изменения [123]
# Аргумент после изменения [123, 1]


### Рекурсивные функции ###
# Рекурсивная функция — это функция, вызывающая сама себя и обрабатывающая полученный результат до тех пор, пока
# не достигнем терминального условия (условия остановки).
def fact(n):
    if n == 1:
        return 1
    return n * fact(n - 1)

# Последовательность Фибоначчи начинается с 1 и 1, после чего каждое новое число является результатом сложения двух
# предыдущих чисел.
def rec_fibb(n):
   if n == 1:
       return 1
   if n == 2:
      return 1
   return rec_fibb(n - 1) + rec_fibb(n - 2)

rec_fibb(10)  # 55

# С помощью рекурсивной функции найдите сумму чисел от 1 до n.
def rec_sum(n):
    if n == 1:
        return 1
    return n + rec_sum(n - 1)

# С помощью рекурсивной функции разверните строку.
def reverse_str(string):
   if len(string) == 0:
       return ''
   else:
       return string[-1] + reverse_str(string[:-1])

reverse_str('test')  # tset

# Дано натуральное число N. Вычислите сумму его цифр.
def sum_digit(n):
   if n < 10:
       return n
   else:
       return n % 10 + sum_digit(n // 10)

sum_digit(123)  # 6

### Функции-генераторы ###
# Синтаксис функций-генераторов отличается от обычных функции только оператором yield, он используется вместо
# оператора return.
def fib():
    a, b = 0, 1
    yield a
    yield b

    while True:
        a, b = b, a + b
        yield b

for num in fib():
   print(num)

# Создайте функцию-генератор, возвращающую бесконечную последовательность натуральных чисел. По умолчанию, она
# начинается с единицы и шагом 1, но пользователь может указать любой шаг и любое число в качестве аргумента функции,
# с которого будет начинаться последовательность.
def count(start=1, step=1):
    counter = start
    while True:
        yield counter
        counter += step


# Создайте генератор цикла, то есть в функцию на входе будет передаваться массив, например, [1, 2, 3],
# генератор будет вечно работать возвращая 1 2 3 1 2 3… и так далее.
def repeat_list(list_):
   list_values = list_.copy()
   while True:
       value = list_values.pop(0)
       list_values.append(value)
       yield value

for i in repeat_list([1, 2, 3]):
   print(i)

### Итераторы ###
# это объект, который возвращает свои элементы по одному за раз.
iter(int)  # TypeError: 'type' object is not iterable
iter([1, 2, 3])  # <list_iterator at 0x7fb593ca1940>

# Логика работы с итераторами в языке Python следующая:

# - Получаем итератор с помощью функции iter(iterable_object).
# - Вызываем много раз next(iterator) от полученного итератора.
# - Когда получим ошибку StopIteration, прекращаем работу.
# В качестве примера возьмем строку и получим от неё итератор:
str_ = "my tst"
str_iter = iter(str_)

print(type(str_))  # строка
print(type(str_iter))  # итератор строки
# Далее с помощью функции next будем получать элементы, но не от самой строки, а от итератора строки:

# Получим первый элемент строки
print(next(str_iter))  # m

# Получим ещё несколько элементов последовательности
print(next(str_iter))  # y
print(next(str_iter))  #
print(next(str_iter))  # t
print(next(str_iter))  # s
print(next(str_iter))  # t
# После того, как элементы закончились, если мы попытаемся получить ещё один элемент, то получим
# соответствующую ошибку:

# Проверить, что будет происходить после окончания последовательности
print(next(str_iter))

---------------------------------------------------------------------------
StopIteration                             Traceback (most recent call last)
<ipython-input-33-124ff1f7eb56> in <module>
      1 # Проверить, что будет происходить после окончания последовательности
----> 2 print(next(str_iter))

StopIteration:


### Функции высшего порядка ###
# Это функция, принимающая в качестве аргументов другие функции или возвращающая другую функцию в качестве результата
def twice_func(inside_func):
    """Функция, выполняющая дважды функцию принятую в качестве аргумента"""
    inside_func()
    inside_func()


def hello():
    print("Hello")


test = twice_func(hello)
# Hello
# Hello


### Замыкание функций ###
# Функция, в теле которой присутствуют ссылки на переменные, объявленные вне тела этой функции в окружающем коде
# и не являющиеся её аргументами.
def make_adder(x):
   def adder(n):
       return x + n # захват переменной "x" из nonlocal области
   return adder  # возвращение функции в качестве результата


### Декораторы ###
# Декораторы предназначены для подключения любого дополнительного поведения к основной функции, называемой
# декорируемой функцией, которое может выполняться до, после или даже вместо основной функции. При этом исходный
# код декорируемой функции никак не затрагивается.
def my_decorator(a_function_to_decorate):
    # Здесь мы определяем новую функцию - «обертку». Она нам нужна, чтобы выполнять
    # каждый раз при вызове оригинальной функции, а не только один раз
    def wrapper():
        # здесь поместим код, который будет выполняться до вызова, потом вызов
        # оригинальной функции, потом код после вызова
        print("Я буду выполнен до основного вызова!")

        result = a_function_to_decorate()  # не забываем вернуть значение исходной функции

        print("Я буду выполнен после основного вызова!")
        return result

    return wrapper

def my_function():
   print("Я - оборачиваемая функция!")
   return 0

print(my_function())
# Я - оборачиваемая функция!
# 0

decorated_function = my_decorator(my_function)  # декорирование функции
print(decorated_function())
# Я буду выполнен до основного вызова!
# Я - оборачиваемая функция!
# Я буду выполнен после основного вызова!
# 0

# Попробуем замерить время выполнения системной функции для возведения числа в степень 2 и соответствующего оператора:
import time


def decorator_time(fn):
   def wrapper():
       print(f"Запустилась функция {fn}")
       t0 = time.time()
       result = fn()
       dt = time.time() - t0
       print(f"Функция выполнилась. Время: {dt:.10f}")
       return dt  # задекорированная функция будет возвращать время работы
   return wrapper


def pow_2():
   return 10000000 ** 2


def in_build_pow():
   return pow(10000000, 2)


pow_2 = decorator_time(pow_2)
in_build_pow = decorator_time(in_build_pow)

pow_2()
# Запустилась функция <function pow_2 at 0x7f938401b158>
# Функция выполнилась. Время: 0.0000011921

in_build_pow()
# Запустилась функция <function in_build_pow at 0x7f938401b620>
# Функция выполнилась. Время: 0.0000021458


### Синтаксический сахар ###
# Синтаксические возможности, применение которых не влияет на поведение программы, но делает использование
# языка более удобным для человека.
@my_decorator
def my_function():
    pass


def my_decorator(fn):
   def wrapper():
       fn()
   return wrapper  # возвращается задекорированная функция, которая заменяет исходную

# выведем незадекорированную функцию
def my_function():
   pass
print(my_function)  # <function my_function at 0x7f938401ba60>

# выведем задекорированную функцию
@my_decorator
def my_function():
   pass
print(my_function)  # <function my_decorator.<locals>.wrapper at 0x7f93837059d8>


# Передача аргументов в декорируемую функцию
# декоратор, в котором встроенная функция умеет принимать аргументы
def do_it_twice(func):
   def wrapper(*args, **kwargs):
       func(*args, **kwargs)
       func(*args, **kwargs)
   return wrapper

@do_it_twice
def say_word(word):
   print(word)

say_word("Oo!!!")
# Oo!!!
# Oo!!!

# Вот универсальный шаблон для декоратора:

def my_decorator(fn):
    print("Этот код будет выведен один раз в момент декорирования функции")
    def wrapper(*args, **kwargs):
        print('Этот код будет выполняться перед каждым вызовом функции')
        result = fn(*args, **kwargs)
        print('Этот код будет выполняться после каждого вызова функции')
        return result
    return wrapper

# Напишите декоратор, который будет подсчитывать количество вызовов декорируемой функции. Для хранения переменной,
# содержащей количество вызовов, используйте nonlocal область декоратора.
def counter(func):
   count = 0
   def wrapper(*args, **kwargs):
       nonlocal count
       func(*args, **kwargs)
       count += 1
       print(f"Функция {func} была вызвана {count} раз")
   return wrapper

@counter
def say_word(word):
   print(word)

say_word("Oo!!!")
# Oo!!!
# Функция <function say_word at 0x7f93836d47b8> была вызвана 1 раз

say_word("Oo!!!")
# Oo!!!
# Функция <function say_word at 0x7f93836d47b8> была вызвана 2 раз


# Напишите декоратор, который будет сохранять результаты выполнения декорируемой функции в словаре. Словарь
# должен находиться в nonlocal области в следующем формате: по ключу располагается аргумент функции, по значению
# результат работы функции, например, {n: f(n)}.
def cache(func):
   cache_dict = {}
   def wrapper(num):
       nonlocal cache_dict
       if num not in cache_dict:
           cache_dict[num] = func(num)
           print(f"Добавление результата в кэш: {cache_dict[num]}")
       else:
           print(f"Возвращение результата из кэша: {cache_dict[num]}")
       print(f"Кэш {cache_dict}")
       return cache_dict[num]
   return wrapper


# Напишите функцию D(a,b,c), возвращающую дискриминант квадратного уравнения.
def quadratic_solve(a,b,c):
    if D(a,b,c) < 0:
        return "Нет вещественных корней"
    elif D(a,b,c) == 0:
        return -b/(2*a)
    else:
        return (-b-D(a,b,c)**0.5)/(2*a), (-b+D(a,b,c)**0.5)/(2*a)

# Напишите рекурсивную функцию, находящую минимальный элемент списка без использования циклов и встроенной
# функции min():
def min_list(L):
    if len(L) == 1:
        return L[0]
    return L[0] if L[0] < min_list(L[1:]) else min_list(L[1:])

# Напишите рекурсивную функцию, которая зеркально разворачивает число. Предполагается, что число не содержит нули:
def mirror(a, res=0):
    if a == 0:
        return res
    else:
        return mirror(a // 10, res * 10 + a % 10)

# Поработаем над более сложной рекурсивной функцией. Сейчас попробуем реализовать функцию equal(N, S),
# проверяющую, совпадает ли сумма цифр числа N с числом S. При написании программы следует обратить внимание
# на то, что, если S стала отрицательной, то необходимо сразу вернуть False.
def equal(N, S):
    if S < 0:
        return False
    if N < 10:
        return N == S
    else:
        return equal(N // 10, S - N % 10)

# Реализуйте функцию-генератор, каждое значение которого — приближение числа e с некоторым числом n.
def e():
    n = 1

    while True:
        yield (1 + 1 / n) ** n
        n += 1

# Декоратор, который позволяет вызвать функцию, только если она вызывается авторизованным пользователем.
yesno = input("""Введите Y, если хотите авторизоваться или N, 
             если хотите продолжить работу как анонимный пользователь: """)

auth = yesno == "Y"

def is_auth(func):
    def wrapper():
        if auth:
            print("Пользователь авторизован")
            func()
        else:
            print("Пользователь неавторизован. Функция выполнена не будет")
    return wrapper

@is_auth
def from_db():
    print("some data from database")

from_db()

# Реализуйте функцию-декоратор, которая проверяет доступ к функции по username пользователя. Все username
# пользователей хранятся в глобальной области видимости в списке USERS.

USERS = ['admin', 'guest', 'director', 'root', 'superstar']

yesno = input("""Введите Y, если хотите авторизоваться или N, 
             если хотите продолжить работу как анонимный пользователь: """)

auth = yesno == "Y"

if auth:
    username = input("Введите ваш username:")

def has_access(func):
    def wrapper():
        if username in USERS:
            print("Авторизован как", username)
            func()
        else:
            print("Доступ пользователю", username, "запрещен")
    return wrapper

@is_auth
@has_access
def from_db():
    print("some data from database")

from_db()

# C помощью метода строки str.lower переведите все элементы списка в нижний регистр.

L = ['THIS', 'IS', 'LOWER', 'STRING']

print(list(map(str.lower, L)))

# Функция filter возвращает итератор с теми элементами из входящей последовательности, для которых функция
# вернула True.
# Из заданного списка вывести только положительные элементы
def positive(x):
    return x > 0  # функция возвращает только True или False

result = filter(positive, [-2, -1, 0, 1, -3, 2, -3])

# Возвращается итератор, т.е. перечисляйте или приводите к списку
print(list(result))   # [1, 2]

# Отфильтруйте из заданного списка только четные элементы.
# [-2, -1, 0, 1, -3, 2, -3]
def even(x):
    return x % 2 == 0

result = filter(even, [-2, -1, 0, 1, -3, 2, -3])
print(list(result))

# В каких случаях стоит использовать map и filter?
map(func, list1)  # итератор, но никаких вычислений не будет произведено
list(map(...))  # только здесь появляется объект

[func(i) for i in list1]  # сразу готовый объект

[func(i) for i in list1] == list(map(func, list1))  # результат один и тот же


### Lambda функции ###
# Для одноразовых функций были сделаны анонимные функции. Объявляются они по ключевому слову lambda.
# эти две функции выполняют одно и тоже — складывают два числа
def my_function(x1, x2):  # Обычная функция
   return x2 + x1

lambda x1, x2: x2 + x1  # Анонимная функция

# Анонимные функции могут содержать в себе только одну инструкцию (выражение), которую они выполняют.
# Возвести первые 10 натуральных чисел в квадрат
list(map(lambda x: x ** 2, range(1, 11)))  # правильно
# [1, 4, 9, 16, 25, 36, 49, 64, 81, 100]

# По умолчанию словарь сортируется по ключам.
d = {2 : "c", 1 : "d", 4 : "a", 3 : "b"}

# Чтобы отсортировать его по ключам, нужно сделать так:
print(dict(sorted(d.items())))
# {1: 'd', 2: 'c', 3: 'b', 4: 'a'}

# А вот чтобы отсортировать словарь по значениям, необходимо указать, что сортировать нужно по второму элементу
# кортежа ключ-значение. У встроенной функции sortred() можно задать аргумент key, который укажет, по какому
# ключу нужно производить сортировку.
sorted(d.items(), key=lambda x: x[1])  # сортировка по значению словаря


# Предположим у нас есть список с данными о росте и весе людей. Задача — отсортировать их по индексу массы тела.
# Он вычисляется по формуле: рост в метрах возвести в квадрат, потом массу тела в килограммах разделить на
# полученную цифру.

# (вес, рост)
data = [
   (82, 191),
   (68, 174),
   (90, 189),
   (73, 179),
   (76, 184)
]
sorted(data, key = lambda x: x[0] / x[1] ** 2)

# Из списка в предыдущем задании найдите кортеж с минимальным индексом массы тела:
print(min(data, key=lambda x: x[0] / x[1] ** 2))  # отбор по ключу

# Выведите длину каждого элемента в списке.
a = ["asd", "bbd", "ddfa", "mcsa"]

print(list(map(len, a)))

# Переведите все строки из списка в верхний регистр (заглавные буквы).

a = ["это", "маленький", "текст", "обидно"]
print(list(map(str.upper, a)))