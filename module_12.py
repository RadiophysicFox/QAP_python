### Множественное присваивание ###

# В одной строке можно присвоить значение сразу нескольким переменным:
a, b = "some_string_a", "some_string_b"

# Обмен значений двух переменных:
# «Классический» подход с созданием ещё одной переменной как временного хранилища:
temp = a  # сохранили в temp старое значение a
a = b  # в переменную a сохранили значение b
b = temp  # а в переменную b вернули сохраненное значение a

# Множественное присваивание позволяет записать это действие в одной строке:
a, b = b, a

### Программа анкета ###

first_name = input("Введите ваше имя:")
last_name = input("Введите вашу фамилию:")
age = input("Введите ваш возраст:")
city = input("Введите город проживания:")

# Выводим пустую строку
print("")

# Выводим приветствие, подставляя имя и фамилию пользователя,
# которые он ввел с клавиатуры
print("Привет,", first_name, last_name, "!")

# Выводим пустую строку
print("")

# Выводим фиксированный текст для удобства просмотра
print("Ваш профиль:")

# Выводим возраст и город, которые указал пользователь
print("Возраст:", age, "лет")
print("Город:", city)


### НЕИЗМЕНЯЕМЫЕ ТИПЫ ДАННЫХ ###

### Целые числа ###

# Объекты типа int предназначены для хранения целочисленных данных.
a = 1
b = 73
c = -12
d = 2

# С помощью функции type() можем удостовериться, что в переменных хранится целочисленный объект:
print(type(a))
# <class 'int'>
print(type(b))
# <class 'int'>
print(type(c))
# <class 'int'>
print(type(d))
# <class 'int'>

# С такими объектами можно производить операции: сложение, вычитание, умножение и возведение в степень:
e = a+b
print(e)
print(type(e))
# 74
# <class 'int'>

f = b*c
print(f)
print(type(f))
# -876
# <class 'int'>

g = b**d  # оператор возведения в степень в python обозначается как **
print(g)
print(type(g))
# 5329
# <class 'int'>

# Посмотрим, как будут вести себя целые числа при использовании «обычного» деления:
a = 5/2
print(a)
# 2.5

# Операция целочисленного деления // возвращает целую часть результата, отбрасывая всю дробную часть:
print(1 // 3)
# 0
print(3 // 3)
# 1
print(29 // 3)
# 9

# Оператор % (по модулю) дает остаток от деления первого аргумента на второй:
print(1 % 3)  # ближайшее число, которое нацело делится на 3 - это ноль
# 1
print(3 % 3)  # в этом примере сам делитель может нацело разделиться
# 0
print(29 % 3)  # здесь ближайшее число - 27, и поэтому результат 29-27=2
# 2

# В случае положительных чисел:
a = 5
b = 2
q = a // b  # q = 2
r = a % b  # r = 1

# Получили результат, согласующийся с формулой: максимально близкое число, на которое можно разделить
# нацело — это 2, и остаток в таком случае равен 1.

# В случае отрицательных чисел:
a = -5
b = 2
q = a // b  # хочется получить 2, как и в прошлый раз, но q = -3
r = a % b  # а остаток остался тот же r = 1

# Дело в том, что максимальное число, которое можно нацело разделить на число при условии, что остаток
# будет положительным — это -6. При его делении на 2 получаем -3 и соответствующий остаток, равный 1.

### Числа с плавающей точкой ###

# Под числами с плавающей точкой подразумеваются дробные числа:
x = 0.1
y = 21.5

print(type(x))
# <class 'float'>
print(type(y))
# <class 'float'>

# С числами с плавающей точкой можно производить уже все знакомые операции, в том числе и деление:
z = y / x
print(z)
print(type(z))
# 215.0
# <class 'float'>

# Экспоненциальная форма записи числа:
print(a**100)
# 3.138886636534116e+73 - [мантисса]e[показатель <>степени <>числа 10]

### Обмен значениями ###

# Обмен значениями численных переменных, используя только действия сложения и вычитания:
a = a - b
b = a + b
a = b - a

### Строки ###

# Для представления текстовой информации в Python используются объекты типа str — строки:
some_text = "python"
other_text = 'Java'

# Можно использовать любые кавычки (одинарные и двойные):
introducing = "I'm Ivan"
action = 'Я читаю "Изучаем python" Марка Лутца'

# Можно записывать большие текстовые блоки, используя тройные кавычки:
long_text = '''Здесь может
               находиться
               большой "кусок" кода'''
other_long_text = """Таким образом тоже
                     можно записать"""

# Python позволяет получить доступ к отдельным символам или даже подстрокам, обращаясь к ним по индексам:
s = "python"
print(s[0])
# p
print(s[1:4])
# yth

# Можно прочитать отдельный символ, перезаписать мы его не можем,
# потому что строки являются неизменяемыми данными:
s = "python"
s[0] = 'C'
print(s)
# ожидается вывод "Cython", однако python вернет ошибку:
# TypeError: 'str' object does not support item assignment

# Выражение, находящееся внутри квадратных скобок, называется срезом - [начало:конец:шаг]
s = "Hello!"

print(s[2:])
# llo!

print(s[:4])
# Hell

# Для извлечения каждого второго символа нужно использовать:
print(s[::2])
# Hlo

# Отрицательный шаг позволяет развернуть строку:
print(s[::-1])
# !olleH

# Отрицательные индексы нумеруются от последнего символа к первому:
print(s[-1])
# !

print(s[-3:-1])
# lo

# Встроенная функция len() позволяет узнать длину строки:
print(len(s))
# 6

# Метод find(substr), определённый для строк, позволяет находить символы и подстроки:
print(s.find('e'))  # возвращает индекс
# 1

print(s.find('o!'))  # в случае подстроки возвращает индекс первого символа
# 4

# Если символ или подстрока встречаются несколько раз, то возвращается индекс первого вхождения:
print(s.find('l'))  # встречается в индексах 2 и 3
# 2

# Ряд функций позволяет определить, состоит ли строка из цифр, букв или одновременно из букв и цифр:
print(s.isdigit())  # строка состоит из цифр?
# False

print(s.isalpha())  # строка состоит из букв?
# False

print(s.isalnum())  # строка состоит из цифр и букв?
# False

# Привести все буквы к верхнему регистру (заглавным буквам) или к нижнему регистру (строчным буквам):

print(s.upper())
# HELLO!

print(s.lower())
# hello!

print(s)
# Hello!

# Разделить строку на несколько подстрок:
colors = 'red blue green'
print(colors.split())
# ['red', 'blue', 'green']

path = '/home/user/documents/file.txt'
print(path.split('/'))  # разделитель можно указать в качестве аргумента
# ['', 'home', 'user', 'documents', 'file.txt']

# Объединение строк:
colors = 'red green blue'
colors_joined = ' and '.join(colors.split())  # объединение строк
print(colors_joined)
# red and green and blue

# Программа, которая реализует ввод произвольного количества чисел через пробел и выводит эти же
# самые числа построчно:
numbers = input("Введите числа через пробел:")

numbers_split = numbers.split()
numbers_lines = "\n".join(numbers_split)

print(numbers_lines)

# Преобразование строк

# Ввести в консоль число, а не строку как по умолчанию:
int_num = int(input("Введите целое число: ")) # вводим, например, 256
print(int_num)
# 256
print(type(int_num))  # убеждаемся, что тип данных в переменной - int
# <class 'int'>

# Python позволяет выполнить и обратное преобразование — из числа в строку:
age = 25
my_age = "I'm " + age
# здесь возникнет ошибка TypeError: must be str, not int
# мы хотим сложить строку и целое число, а это запрещено, поэтому нужно так:
my_age = "I'm " + str(age)
print(my_age)
# I'm 25

# Умножение строки на число:
wow = 'wow'
print(wow*5)  # никакой ошибки не возникает
# wowwowwowwowwow

# Форматирование строк - шаблон_строки % (переменные)
age = 25
my_age = "I'm %d years old" % (age)  # в шаблоне присутствует специальный символ %d
print(my_age)
# I'm 25 years old

day = 14
month = 2
year = 2012

print("%d.%02d.%d" % (day, month, year))
# 14.02.2012
print("%d-%02d-%d" % (year, month, day))
# 2012-02-14
print("%d/%d/%d" % (year, day, month))
# 2012/14/2

### Логические переменные ###

# В Python существует тип логических переменных — bool:
t = True
f = False

# Логические значения можно получать и как возвращаемое значение некоторых действий, таких как сравнение:
print(3 > 10)
# False

print(3 < 10)
# True

print(3 == 10)  # равны ли объекты?
# False

# Можно также проверить, содержится ли какой-то символ в строке:
print('r' in 'world')  # проверяем отдельный символ
# True

print('th' in 'python')  # проверяем целую подстроку
# True

print('the' in 'python')
# False

### Кортеж ###

# Для сохранения нескольких объектов в одну переменную можно использовать кортежи (tuple):
date = (1, 'january', 2020)

# После чего можно получить доступ к отдельным переменным по индексу:
print(date[0])
# 1
print(date[1])
# january
print(date[2])
# 2020

#  В связи с тем, что кортеж, так же как и другие приведённые выше типы, является неизменяемым,
#  попытка его модифицировать приведёт к ошибке:
date[0] = date[0] + 1
# TypeError: 'tuple' object does not support item assignment

### Неизменяемость строк ###
s1 = "foo"
s2 = "bar"

# Допишем вторую строку к первой:
s1 = s1+s2
print(s1)
# foobar

# Воспользуемся встроенной функцией id(), которая возвращает уникальный идентификатор любого объекта:
s1 = "foo"
print(id(s1), s1)  # проверяем идентификатор
# 139953609727144, foo

s2 = "bar"
print(id(s2), s2)  # проверяем идентификатор
# 139953609727088, bar

s1 = s1+s2
print(id(s1), s1)  # проверяем идентификатор
# 139953459591296, foobar

# Значит старая строка foo была стёрта, а вместо неё записана новая, не зависимая от неё строка.

### Преобразование типов ###

# Возможность явно преобразовать один тип в другой — приведение типов с помощью конструкции:
# t(var)
# В данном выражении var — это объект, который подлежит преобразованию, а t — это тип (int или float),
# к которому необходимо преобразовать:
print(float(1))
# 1.0

# Аналогично преобразуются числа с плавающей точкой в целые числа:
print(int(3.14))
# 3

# Приведение float к int только отбрасывает дробную часть:
print(int(2.8))  # ожидается 3, т.к. 2.8>2.5
# 2

# Для корректного округления чисел с плавающей точкой необходимо пользоваться функцией round():
print(round(1.00+0.01-3.01))
# -2

print(3.14/2)
# 1.57
print(round(3.14/2, 1))  # второй аргумент - желаемое количество знаков
# 1.6

### ИЗМЕНЯЕМЫЕ ТИПЫ ДАННЫХ ###

### Списки ###

# Пустой список:
s = []

# Наполненный список:
s = [0, 'hello', (1, 'a')]

# Добавление объекта осуществляется с помощью метода append():
letters = ['a', 'b', 'c', 'd']
# с помощью метода append() мы добавляем ещё один элемент в список
letters.append('e')
print(letters)
# ['a', 'b', 'c', 'd', 'e']

# Получение элемента списка по индексу:
print(letters[1])
# b
print(letters[0])
# a
print(letters[-1])
# е
print(letters[4])
# e

# Длина списка:
print(len(letters))
# 5
print(letters[len(letters)-1])
# e

# Удаление объектов из списка - метод pop():
print(letters)
# ['a', 'b', 'c', 'd', 'e', 'f', 'g']
letters.pop()  # вызов метода без аргументов удаляет последний элемент списка
print(letters)
# ['a', 'b', 'c', 'd', 'e', 'f']
# был удалён последний элемент

letters.pop(0)  # или можно удалить элемент по его индексу
print(letters)
# ['b', 'c', 'd', 'e', 'f']
# был удалён нулевой элемент

letters.pop(3)  # и необязательно удалять из начала или конца списка
print(letters)
# ['b', 'c', 'd', 'f']
# был удалён элемент с индексом 3

# Использование срезов для списков:
L = ["а", "б", "в", 1, 2, 3, 4]
print(L[1:4])
# ["б", "в", 1]

L = ["а", "б", "в", 1, 2, 3, 4]
print(L[::3])
# ["а", 1, 4]

L = ["а", "б", "в", 1, 2, 3, 4]
print(L[3::-1])
# [1, "в", "б", "а"]

L = ["а", "б", "в", 1, 2, 3, 4]
print(L[:3:-1])
# [4, 3, 2]

# Выполнить определённые действия для каждого элемента списка - функция map(function, list):
# имеем список с числами с плавающей точкой
L = [3.3, 4.4, 5.5, 6.6]

# печатаем сам объект map
print(map(round, L))  # к каждому элементу применяем функцию округления
# <map object at 0x7fd7e86eb6a0>

# и результат его преобразования в список
print(list(map(round, L)))
# [3, 4, 6, 7]

# Программа, которая преобразовывает список строковых представлений чисел в объекты численного типа данных:
L = ['3.3', '4.4', '5.5', '6.6']
print(list(map(float, L)))

# Программа для преобразования строки в числа и получения их суммы:
string = input("Введите числа через пробел:")

list_of_strings = string.split()  # список строковых представлений чисел
list_of_numbers = list(map(int, list_of_strings)) # список чисел

print(sum(list_of_numbers[::3]))  # sum() вычисляет сумму элементов списка

# Программа, которая на вход получает последовательность чисел, а выводит модифицированный список:
# 1. Первое и последнее числа последовательности должны поменяться местами.
# 2. В конец списка нужно добавить сумму всех чисел.

# все операции - деление строки по пробелам, преобразование к числам
# и приведение объекта map к типу список, можно делать в одной строке
L = list(map(float, input().split()))

# обмениваем первое и последнее число
# с помощью множественного присваивания
L[0], L[-1] = L[-1], L[0]

# находим сумму и добавляем её в конец списка
L.append(sum(L))
print(L)

### Словари ###

person = {} # с помощью фигурных скобок можно создать словарь

# словарь заполняется по принципу - ключ:объект (через двоеточие)
person = {'name' : 'Ivan Petrov'}

# в него можно также добавлять новые объекты по ключу
person['age'] = 25
person['email'] = 'ivan_petrov@example.com'
person['phone'] = '8(800)555-35-35'
print(person)
# {'name': 'Ivan Petrov', 'age': 25, 'email': 'ivan_petrov@example.com', 'phone': '8(800)555-35-35'}

# Попытка извлечения объекта по несуществующему ключу приведёт к ошибке:
print(person['address'])
# KeyError: 'address'

# Можно отдельно получить список ключей:
print(person.keys())
# dict_keys(['name', 'age', 'email', 'phone'])

# Или список значений:
print(person.values())
# dict_values(['Ivan Petrov', 25, 'ivan_petrov@example.com', '8(800)555-35-35'])

# Из словаря аналогично спискам можно удалить объект по его ключу:
print(person)
# {'name': 'Ivan Petrov', 'age': 25, 'email': 'ivan_petrov@example.com', 'phone': '8(800)555-35-35'}
person.pop('phone')
print(person)
# {'name': 'Ivan Petrov', 'age': 25, 'email': 'ivan_petrov@example.com'}

# Программа, которая получает на вход название книги, фамилию автора и год выпуска. Полученные данные
# должны быть преобразованы в словарь и в таком представлении выведены в консоль:
title = input("Введите название книги:")
author = input("Введите фамилию автора:")
year = int(input("Введите год издания:"))

book = {'title': title,
        'author': author,
        'year': year}

print(book)

# Программа: база данных абитуриентов, поступающих в университет:
abit1 = {"ФИО" : 'Фадеев О.Е.', "Количество баллов" : 283, "Заявление" : True}
abit2 = {"ФИО" : 'Дружинин И.Я.', "Количество баллов" : 278, "Заявление" : False}
abit3 = {"ФИО" : 'Афанасьев Д.Н.', "Количество баллов" : 276, "Заявление" : True}
abits = [abit1, abit2, abit3]
print(abits)
# [{'ФИО': 'Фадеев О.Е.', 'Количество баллов': 283, 'Заявление': True}, {'ФИО': 'Дружинин И.Я.',
# 'Количество баллов': 278, 'Заявление': False}, {'ФИО': 'Афанасьев Д.Н.', 'Количество баллов': 276,
# 'Заявление': True}]

### Множества ###

# Множество — это неупорядоченный набор уникальных элементов. Иными словами, во множествах не могут
# повторяться элементы, а хранятся они в памяти компьютера в произвольном порядке.

# Создание множества через синтаксис { }:
a = {'a', 'b', 'c', 'd'}

# Создание множества из списка с помощью приведения типов:
L = [1,1,2,3,2]
c = list(set(L))  # set делает множество из списка, list возвращает множество к виду списка
print(c)
# [1,2,3]

# Программа, которая на вход принимает текст и выводит количество уникальных символов:
text = input("Введите текст:")
unique = list(set(text))
print("Количество уникальных символов: ", len(unique))

# Программа: Пусть у нас есть множество абонентов (для простоты — фамилии) и множество должников,
# а мы хотим получить множество абонентов, не имеющих долгов:
abons = {"Иванов", "Петров", "Васильев", "Антонов"}
debtors = {"Петров", "Антонов"}
non_debtors = abons.difference(debtors)
print(non_debtors)
# {'Васильев', 'Иванов'}

### Идентичность ###

list_1 = ['a', 'b', 'c']
list_2 = list_1
list_3 = list(list_1)
print(list_1)
print(list_2)
print(list_3)

# на выходе в консоли получим:
['a', 'b', 'c']
['a', 'b', 'c']
['a', 'b', 'c']

# В приведённом выше примере мы видим, что они указывают на идентичные списки.
# Затем проверяем равенство этих списков.
print(list_1 == list_2)
print(list_1 == list_3)

# Мы получаем такой результат:
True
True

# Это потому, что их значения list_1, list_2, list_3 равны, тогда условие становится истинным.
print(list_1 is list_2)
print(list_1 is list_3)

# При записи кода выше мы получаем в консоли такой результат:
True
False

# Здесь мы можем увидеть (list_1 is list_3) False, потому что list_1 и list_3 указывают на два разных
# объекта, даже если их содержимое может быть одинаковым. Таким образом, мы можем сказать, что «is»
# вернет True, если две переменные указывают на один и тот же объект, и «==», если объекты, на которые
# ссылаются переменные, равны.

# При работе со списками есть особенность, которую необходимо рассмотреть:

L = ['Hello', 'world']
M = L

print(M is L)
# True

# Очевидно, что эти списки будут равны по своим значениям (сравнивая через ==). И при таком
# присваивании в M скопируется не сам список L, а его идентификатор! Поэтому, изменяя список M,
# мы увидим неожиданные изменения в списке L.
M.append('!')
print(L)
# ['Hello', 'world', '!']

# Чтобы избежать такого поворота событий, список нужно копировать:

M = L.copy()
print(M is L)
# False

### Неизменяемость кортежей ###

# Можно создать список (list) внутри кортежа:
shopping_center = ("Галерея", "Санкт-Петербург", "Лиговский пр., 30", ["H&M", "Zara"])
shopping_center[-1].append("Uniqlo")
print(shopping_center)
# ('Галерея', 'Санкт-Петербург', 'Лиговский пр., 30', ['H&M', 'Zara', 'Uniqlo'])

# Программа для сравнения идентификаторов списков до и после обновления:
shopping_center = ("Галерея", "Санкт-Петербург", "Лиговский пр., 30", ["H&M", "Zara"])
list_id_before = id(shopping_center[-1])
shopping_center[-1].append("Uniqlo")
list_id_after = id(shopping_center[-1])
print(list_id_before == list_id_after)




